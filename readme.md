# 硬件算法chisel实现
硬件算法的chisel实现，主要目的是学习chisel，顺便提交作为数电的期中作业

注意:项目参考设计都已列出,可能存在部分遗漏,如果有发现遗漏或者有建议可以给我提issue,项目后续会更加完善..压缩器设计可以参考香山处理器.
树形加法建议参考rockiet chip

## 加法的设计
注意:本次的设计不考虑异常和条件,如果需要判断是否有溢出或者其他条件需要更改设计(例如在设计算数逻辑单元的时候)


1. Ripple-Carry 加法器
    - 描述：Ripple-Carry 加法器是一种基本的加法电路，用于将两个二进制数相加。它的基本原理是从最低位（LSB）开始，逐位进行加法操作，并将进位传播到下一位。这种加法器在每个时钟周期内只能处理一位加法，因此速度较慢。
    - 优点：简单，易于理解。
    - 缺点：速度较慢，因为每个 carry 都要传播到下一个位。

2. Manchester 加法器
    - 描述：用于实现 half-adder 的逻辑，用于每位加法的进位生成。
    - 优点：可以实现每位的加法和进位生成。
    - 缺点：速度仍然不是最优的。

3. Carry-Look-Ahead 加法器
    - 描述：预计算可能的 carry，减少 carry 传播。
    - 优点：速度快，因为它预先计算并消除了不必要的 carry。
    - 缺点：复杂度较高。

4. Ling’s 加法器
    - 描述：改进版的 Carry-Look-Ahead，用于减少传播 delay。
    - 优点：进一步减少了延迟。
    - 缺点：复杂度高。

5. Conditional-Sum 加法器
    - 描述：使用逻辑操作符直接计算两个数的和。
    - 优点：可以直接给出结果，不需要进位。
    - 缺点：仅适用于部分加法。

6. Carry-Select 加法器
    - 描述：使用查找表来选择进位。
    - 优点：可以非常快速地选择进位。
    - 缺点：需要查找表，增加了硬件复杂度。

7. Carry-Skip 加法器
    - 描述：优化加法过程，跳过不需要的进位。
    - 优点：提高了速度，减少了延迟。
    - 缺点：复杂度较高。

8. Hybrid 加法器 (Lynch and Swartzlander)
    - 描述：结合了多种技术以优化性能。
    - 优点：性能优化，减少了延迟。
    - 缺点：复杂度高。
## 乘法器设计

1. Sequential 乘法器
    - 描述：逐位进行乘法操作。
    - 优点：直接，简单。
    - 缺点：速度较慢。

2. Booth’s 算法
    - 描述：用于二进制数的乘法。
    - 优点：优化了低位数的乘法。
    - 缺点：复杂度较高。

3. Modified Booth’s 算法
    - 描述：Booth’s 算法的改进版本。
    - 优点：提高了性能。
    - 缺点：复杂度较高。

4. Two’s Complement 数组乘法器
    - 描述：用于实现 Two’s Complement 数的乘法。
    - 优点：可以处理负数。
    - 缺点：仅适用于特定类型的数。

5. Fused 乘法器-加法器
    - 描述：将乘法和加法结合在一个单元中。
    - 优点：提高了性能。
    - 缺点：复杂度较高。

6. 常数乘法器
    - 描述：用于乘以一个常数。
    - 优点：简单，直接。
    - 缺点：仅适用于乘以特定常数。
